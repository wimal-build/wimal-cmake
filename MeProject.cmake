# Parse the project name and project version from the given project string.
function(me_parse_project project _name _version _libname)
    if(project MATCHES "^(.*[^-])-([^-]+)$")
        set(${_name} ${CMAKE_MATCH_1} PARENT_SCOPE)
        set(${_version} ${CMAKE_MATCH_2} PARENT_SCOPE)
        set(${_libname} ${CMAKE_MATCH_1} PARENT_SCOPE)
    elseif(project MATCHES "^(.*[^-])-([^-]+)--(.+)$")
        set(${_name} ${CMAKE_MATCH_1} PARENT_SCOPE)
        set(${_version} ${CMAKE_MATCH_2} PARENT_SCOPE)
        set(${_libname} ${CMAKE_MATCH_3} PARENT_SCOPE)
    endif()
endfunction(me_parse_project)

# Create a project.
#
# Params for all projects:
# - 3RD: Create a third-party project.
# - NO_PIC: Do not set `CMAKE_POSITION_INDEPENDENT_CODE`.
# - NO_CXX11: Do not set `CMAKE_CXX_STANDARD` to 11.
# - DEPENDS: List of projects that this project depends on.
# - LIBS: List of libraries required for this project on linking.
# - TEST_DEPENDS: List of projects that test projects depends on.
# - TEST_LIBS: List of libraries required for test projects on linking.
# - SOURCE_DIR: The source folder of this project.
#
# Params for third-party projects:
# - See me_project_3rd.
#
# The following variables may be set by this function:
# - ME_PROJECT
# - ME_PROJECT_NAME
# - ME_PROJECT_VERSION
# - ME_SOURCE_DIR
# - ME_TEST_DIR
# - ME_BUILD_DIR
# - ME_INSTALL_PREFIX
# - ME_DEPENDS
# - ME_PKG_CONFIG_DIR
#
# A custom output will be generated by this function:
# - ALWAYS: Targets that depend on this output will always be built.
function(me_project project)
    set(X_OPTIONS 3RD ALIAS NO_PIC NO_CXX11 NO_PC)
    set(X_SINGLES SOURCE_DIR)
    set(X_MULTIS DEPENDS LIBS TEST_DEPENDS TEST_LIBS)
    cmake_parse_arguments(X "${X_OPTIONS}" "${X_SINGLES}" "${X_MULTIS}" ${ARGN})

    if(NOT X_ALIAS)
        if(NOT X_SOURCE_DIR)
            set(X_SOURCE_DIR "${CMAKE_CURRENT_SOURCE_DIR}/sources")
        endif()

        set(ME_PROJECT ${project})
        set(ME_SOURCE_DIR "${X_SOURCE_DIR}")
        set(ME_TEST_DIR "${CMAKE_CURRENT_SOURCE_DIR}/tests")
        set(ME_BUILD_DIR "${ME_BUILD_ROOT}/${project}/build")
        set(ME_INSTALL_PREFIX "${ME_BUILD_ROOT}/${project}/install")
        me_parse_project(${ME_PROJECT} ME_PROJECT_NAME ME_PROJECT_VERSION ME_PROJECT_LIBNAME)

        set(ME_PROJECT ${ME_PROJECT} PARENT_SCOPE)
        set(ME_PROJECT_NAME ${ME_PROJECT_NAME} PARENT_SCOPE)
        set(ME_PROJECT_VERSION ${ME_PROJECT_VERSION} PARENT_SCOPE)
        set(ME_SOURCE_DIR ${ME_SOURCE_DIR} PARENT_SCOPE)
        set(ME_TEST_DIR ${ME_TEST_DIR} PARENT_SCOPE)
        set(ME_BUILD_DIR ${ME_BUILD_DIR} PARENT_SCOPE)
        set(ME_DEPENDS ${X_DEPENDS} PARENT_SCOPE)
        set(ME_INSTALL_PREFIX ${ME_INSTALL_PREFIX} PARENT_SCOPE)
    endif()

    if(CMAKE_SCRIPT_MODE_FILE)
        if(X_3RD)
            set(ENV{ALL} 1)
        endif()
        if(NOT X_ALIAS)
            include(MeMakefile)
            if(EXISTS ${ME_SOURCE_DIR}/main.cpp OR EXISTS ${ME_SOURCE_DIR}/dllmain.cpp)
                set(ME_INSTALL ON)
            endif()
            me_makefile_make(${project})
        endif()
        return()
    endif()

    add_custom_command(OUTPUT ALWAYS COMMENT "")

    if(NOT X_3RD)
        # TODO: Check if these variables will affect the imported projects.
        if(NOT X_NO_PIC)
            set(CMAKE_POSITION_INDEPENDENT_CODE ON)
        endif()
        if(NOT X_NO_CXX11)
            set(CMAKE_CXX_STANDARD 11)
        endif()

        me_build_lib()
        me_build_dll()
        me_build_exe()
        me_build_test()
    endif()

    # Clear these properties to avoid affecting the projects that will be imported.
    set_property(DIRECTORY PROPERTY DEFINITIONS)
    set_property(DIRECTORY PROPERTY COMPILE_DEFINITIONS)
    set_property(DIRECTORY PROPERTY COMPILE_OPTIONS)
    set_property(DIRECTORY PROPERTY INCLUDE_DIRECTORIES)
    set_property(DIRECTORY PROPERTY LINK_DIRECTORIES)
    set_property(DIRECTORY PROPERTY LINK_OPTIONS)

    me_import(${X_DEPENDS})

    if(NOT X_3RD)
        add_custom_target(${ME_PROJECT}- DEPENDS ${ME_PROJECT})
        target_include_directories(${ME_PROJECT} PUBLIC ${ME_IMPORTED_INCLUDES})
        if(TARGET ${ME_PROJECT}-exe)
            add_dependencies(${ME_PROJECT}- ${ME_PROJECT}-exe)
            target_include_directories(${ME_PROJECT}-exe PUBLIC ${ME_IMPORTED_INCLUDES})
        endif()
        if(TARGET ${ME_PROJECT}-dll)
            add_dependencies(${ME_PROJECT}- ${ME_PROJECT}-dll)
            target_include_directories(${ME_PROJECT}-dll PUBLIC ${ME_IMPORTED_INCLUDES})
        endif()
        if(TARGET ${ME_PROJECT}-test)
            add_dependencies(${ME_PROJECT}- ${ME_PROJECT}-test)
            target_include_directories(${ME_PROJECT}-test PUBLIC ${ME_IMPORTED_INCLUDES})
        endif()
    endif()

    # Set ME_PKG_CONFIG_DIR for third-party projects.
    if(X_3RD AND NOT X_NO_PC AND NOT X_ALIAS)
        set(X_PC_DIR "${ME_PKG_CONFIG_DIR}")
        foreach(depend ${X_DEPENDS})
            if(${depend}-PREFIX)
                string(
                    CONCAT X_PC_DIR
                    "${X_PC_DIR}" :
                    "${${depend}-PREFIX}/lib/pkgconfig" :
                    "${${depend}-PREFIX}/share/pkgconfig"
                )
            endif()
        endforeach()
        string(
            CONCAT ME_PKG_CONFIG_DIR
        )
        set(ME_PKG_CONFIG_DIR "${X_PC_DIR}" PARENT_SCOPE)
    endif()

    if(X_3RD)
        me_project_3rd(${project} ${ARGN})
        return()
    endif()

    target_link_libraries(${ME_PROJECT} ${X_DEPENDS} ${X_LIBS})
endfunction(me_project)

# Create a third-party project.
#
# - META: Create a meta project (with no targets, usually used by alias projects).
# - ALIAS: Create an alias project (i.e. a library built by another project).
# - SHARED: Create a shared library, otherwise the target will be a static library.
# - NO_PC: Do not generate the ME_PKG_CONFIG_DIR variable.
# - LIB: Override the default library name (full filename).
# - LIBNAME: Override the default library name (i.e. project name).
# - MAKE: Specify the custom target that build the project, default is 'make', which added by
#     me_make().
# - INCLUDES: Specify the include directories relative to the install prefix.
# - INSTALL: Generate an installation target for this project.
#
# A variable will be exported by this function:
# - <project>-PREFIX: Install prefix of <project>.
# - <project>-LIBS: Installed libraries of <project>.
function(me_project_3rd project)
    set(X_OPTIONS META ALIAS SHARED INSTALL)
    set(X_SINGLES LIB LIBNAME MAKE)
    set(X_MULTIS DEPENDS LIBS INCLUDES)
    cmake_parse_arguments(X "${X_OPTIONS}" "${X_SINGLES}" "${X_MULTIS}" ${ARGN})

    if(NOT X_LIBNAME)
        me_parse_project(${project} X_NAME X_VERSION X_LIBNAME)
    endif()

    if(X_SHARED)
        set(X_LIBTYPE SHARED)
    else()
        set(X_LIBTYPE STATIC)
    endif()

    if(NOT X_LIB)
        set(X_LIB_PREFIX ${CMAKE_${X_LIBTYPE}_LIBRARY_PREFIX})
        set(X_LIB_SUFFIX ${CMAKE_${X_LIBTYPE}_LIBRARY_SUFFIX})
        set(X_LIB ${X_LIB_PREFIX}${X_LIBNAME}${X_LIB_SUFFIX})
    endif()

    if(NOT X_INCLUDES)
        set(X_INCLUDES include)
    endif()

    if(NOT X_MAKE)
        set(X_MAKE make)
    endif()

    if(NOT X_ALIAS)
        add_custom_target(${ME_PROJECT}- DEPENDS ${X_DEPENDS} ${X_MAKE})
        if(X_INSTALL)
            install(
                DIRECTORY ${ME_INSTALL_PREFIX}/
                DESTINATION ${CMAKE_INSTALL_PREFIX}
                USE_SOURCE_PERMISSIONS
                COMPONENT ${ME_PROJECT}
            )
            me_install_target(${ME_PROJECT})
        endif()
    endif()

    add_library(${project} ${X_LIBTYPE} IMPORTED GLOBAL)

    if(NOT X_META)
        set(X_IMPORTED_LOCATION ${ME_INSTALL_PREFIX}/lib/${X_LIB})
        set(
            ${project}-LIBS ${X_IMPORTED_LOCATION}
            CACHE PATH
            "Installed libraries of ${project}"
        )
        list(APPEND ${ME_PROJECT}-LIBS ${X_IMPORTED_LOCATION})
        list(REMOVE_DUPLICATES ${ME_PROJECT}-LIBS)
        set_target_properties(
            ${project} PROPERTIES
            IMPORTED_LOCATION ${X_IMPORTED_LOCATION}
        )
        foreach(include ${X_INCLUDES})
            set_property(
                TARGET ${project} APPEND PROPERTY
                INCLUDE_DIRECTORIES ${ME_INSTALL_PREFIX}/${include}
            )
        endforeach()
        target_link_libraries(${project} INTERFACE ${X_DEPENDS} ${X_LIBS})
    endif()

    add_dependencies(${project} ${ME_PROJECT}-)

    set(${project}-PREFIX ${ME_INSTALL_PREFIX} CACHE PATH "Install prefix of ${project}")
    set(
        ${ME_PROJECT}-LIBS ${${ME_PROJECT}-LIBS}
        CACHE INTERNAL
        "Installed libraries of ${ME_PROJECT}" FORCE
    )
endfunction(me_project_3rd)
